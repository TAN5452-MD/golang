# 数组
 如果我们想让数组元素类型为任意类型的话可以使用空接口作为类型。当使用值时我们必须先做一个类型判断
 数组长度最大为 2Gb

 声明的格式是：
 ```
 var identifier [len]type

 ```
 Go 语言中的数组是一种 值类型 所以可以通过new来创建 注意new关键字创造的所有值都是返回指针

# 切片
 ## 不定长的数组就是切片 切片是可索引的 终止索引标识的项不包括在切片内

 1. 切片是一个长度可变的数组
 切片提供了计算容量的函数 cap() 可以测量切片最长可以达到多少 它等于切片从第一个元素开始，到相关数组末尾的元素个数
 声明切片的格式是： var identifier []type
 一个切片未在初始化前默认为nil 长度为0
 

 2. 一个由数字 1、2、3 组成的切片可以这么生成：s := [3]int{1,2,3}[:] 甚至更简单的 s := []int{1,2,3}
 s2 := s[:] 是用切片组成的切片，拥有相同的元素，但是仍然指向相同的相关数组。(因为是引用类型)
 一个切片 s 可以这样扩展到它的大小上限：s = s[:cap(s)]，如果再扩大的话就会导致运行时错误

3. 对于每一个切片 s == s[:i] + s[i:] 
len(s) <= cap(s)
cap始终大于len 方便扩容

4. 切片在内存中的组织方式实际上是一个有3个域的结构体：

>   1.指向数组的指针，2.切片长度，3.切片容量

如果s2是一个slice 你可以将切片向后移动 s2=s2[1:]但是末尾没有移动。**_另外，切片只能向后移动_**

### 注意！绝对不要用指针指向切片


5. 用make创建切片
当数组还没有定义时，我们可以使用make来预先创建一个切片，同时创建数组
 ``` 
 var slice []type = make([]type,len)
 slice := make([]type,len)
 ```

 这里的len是数组的长度并且也是slice的初始长度
 所以 s2 := make([]int, 10) cap(s2)==len(s2)==10
 
 make函数接收2个参数：元素的类型以及切片的元素个数

如果你想创建一个slice，她不占用整个数组那么

slice := make([]type,len,cap)**cap为可选参数**

6. 下面2种方法可以生成相同的切片
   make([]int,50,100)
   new([100]int)[0:50]

7. 因为字符串是纯粹不可变的字节数组，所以他们也可以被切分成切片
8. new 和 make 的区别

new(T)为每个类型T分配一片内存，初始化为0并且返回类型为*T的内存地址 这种方法返回一个指针，他适用于值类型如数组和结构体他相当于&T{}

make(T)返回一个类型为T的初始值，他只适用于3种内建的引用类型：切片、map、和channel

**换言之，new函数分配内存，make函数初始化**