# 指针
### 一个指针变量可以指向任何一个值的内存地址，在32位机器占用4个字节 64位8个 与值的大小无关
### 指针不能指向文字或常量 例如 ptr := &10 就是一个错误的示例
所谓的指针算法，如：pointer+2，移动指针指向字符串的字节数或数组的某个位置）是不被允许的
因此 c = *p++ 在 Go 语言的代码中是不合法的。
### 当程序需要占用大量内存时，使用指针会减少内存占用和提高效率，指针也可以指向另一个指针，可以嵌套引用（不建议）
对一个空指针的反向引用是不合法的，并且会使程序崩溃：
>   var ptr *int = nil *ptr = 0 //报错

### 在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。

### 对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。

变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&取地址操作。

任何类型的指针的零值都是nil

函数中局部变量返回的地址如果被一个指针捕获，则依然有效（该变量不会被gc，因为有指针执向这个变量）

new函数返回的是一个初始值类型的指针变量，下面2个语句相等
```
func newInt() *int {
    return new(int)
}

func newInt() *int {
    var dummy int
    return &dummy
}
```

每次调用new函数都是返回一个新的变量的地址

函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建

局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

### 那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢
从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

### 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间

如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。